Сама по себе концепция динамического массива заключается в том, что класс содержит внутреннее хранилище и время от времени его увеличивает, или даже и уменьшает.

``` c#
abstract class DynArray<T> {
    // PRIVATE СОСТОЯНИЯ
    // БУФЕР для хранения большого массива, в котором
    // предоставляется место для массива по-меньше

    private STANDART_CAPACITY = 10

    // СТАТУЫ
    public GetItem_Ok = 0
    public GetItem_OutOfRange = 1

    // КОНСТРУКТОР

    public DynArray<T> DynArray()

    // КОМАНДЫ

    // предусловие: требуется реаллокация, вызывается метод how_much_elements()
    // постусловие: все значения внутреннего массива до
    // реаллокации сохранились в неизменном порядке, а сам
    // внутренний массив изменился в размере
    public void MakeArray(int new_capacity = STANDART_CAPACITY)

    // предусловие: в массиве найдется место для нового
    // элемента, подразумевается вызов array_has_space()
    // постусловие: в массив добавлен элемент
    public void Append(T itm)

    // предусловие: в буфере найдется место для нового
    // элемента, подразумевается вызов array_has_space(),
    // и MakeArray при необходимости
    // постусловие: в массив добавлен элемент по указанному
    // индексу
    public void Insert(T itm, int index)

    // предусловие: index в рамках текущего размера массива, НЕ БУФЕРА
    // постусловие: элемент по индексу удален, массив сжался,
    // заполнив освободившееся место
    public void Remove(int index)

    // ЗАПРОСЫ

    // предусловие: index в рамках текущего размера массива, НЕ БУФЕРА
    public T GetItem(int index)

    // ДОПОЛНИТЕЛЬНЫЕ ЗАПРОСЫ
    private int how_much_elements() // возвращает число элементов в массиве
    private bool array_has_space() // True; False
    }

    public int get_item_correct() // GetItem_Ok; GetItem_OutOfRange
```
