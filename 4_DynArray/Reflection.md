# Рефлексия по решению последнего задания

Кажется, не до конца я понял концепцию динамического массива. Эталонное решение
предполагает использование курсора, относительно которого ведется добавление
элементов в массив.

Обращая внимание точечно на мои ошибки, существует риск погрязнуть в смятении,
ибо их количество велико. Вместо этого я предлагаю сам себе взглянуть на общие
ошибки мышления.

Одну из таких ошибок можно обнаружить в моем умозаключении по- отношению к
предусловию метода `append`. Я предположил, что предусловием должно являться
наличие свободного места в буфере. Иными словами, я привязался к реализации
динамического массива. Это было в корне не верно, надо было поступить наоборот и
проектировать абстрактный тип данных исходя из формальных требований к этому
типу данных, как это было описано ранее в занятиях.

Другую ошибку я допустил при определении предусловия для метода `Insert` (в
эталонном решении это метод put). Эту же ошибку я допустил и в некоторых других
методах. В своём решении я опёрся на конкретную реализацию динамического массива
и не предусмотрел в предусловии проверку допустимых границ индекса, по которому
ведется вставка в массив. Исходя из моей реализации, ничего не мешает вставлять
элементы и по отрицательным индексам или по выходящим за пределы массива. В
методе `Remove` я также ошибся с индексами в предусловии, но чуть иначе, не
предусмотрел, что отрицательный индекс моё условие удовлетворяет.

Важная оговорка: сами по себе отрицательные индексы ничего плохого не несут, в
python они вполне успешно используются и их не планируют убирать из языка. Но
предусловие не должно быть привязано к реализации или к конкретному языку (по
крайней мере, как мне представляется, на первой итерации разработки типа
данных), поэтому в эталонном решении в предусловии значится "i лежит в
допустимых границах массива". А уж какое множество значений будет являться
допустимым- вопрос последующий.


Мои дополнительные запросы также сильно привязаны к реализации, это ошибка. На
самом деле, они прямо таки и являются частью реализации.


## Если подытожить

Программа минимум для понимания и запоминания:

Проектирование типа данных на основе АТД не производится с привязкой ни к
реализации, ни к семантическим возможностям языка, который планируется
использовать.
