# Двусторонняя очередь

Проектировать будем по аналогии с [двусторонним
списком](../3_TwoWayList/Reference%20solution.md)

Двустороння очередь отличается от обычной тем, что в неё можно можно вставлять
элементы не только в конец очереди, но и в голову. Также и вытаскивать элементы
можно не только из головы, но и из конца.

А также необходимо по заданию совместить эту двустороннюю очередь с обычной в
одну иерархию.

Какие есть варианты того, как это спроектировать?
1) Написать класс, который помимо общей логики очередей,также будет обладать
методами 'положить элемент по идексу i' и 'вытащить элемент по индексу i'. Этот
метод можно было бы сделать приватным, а от класса унаследовать очереди, в
которых определить логику работы их методов, реализовав их через этот
универсальный метод;

2) Написать класс, который реализовал бы общую логику двух очередей (фактически
все методы queue). От него следует унаследовать queue и deque. Queue становится
прямым потомком этого класса, не требующим изменений, а вот в deque лишь
потребуется определить методы "положить элемент в голову", "вытащить элемент из
головы" и "посмотреть на элемент в хвосте".

В принципе, первый вариант смотрится неплохо, но он несет в себе недостаток: не
получится сокрыть родительские методы 'положить/забрать элемент по индексу i' от
дочерних классов. А это может привести к тому, что класс динамический массив, к
примеру, вполне может стать наследником класса Очередь. Такая иерархия
смотрится, откровенно, странно. А еще такая реализация не удовлетворяет
требованию минимального АТД. Метод 'положить/забрать элемент по индексу i'
вообще- то очередям и не нужен, из всей очереди они оперируют двумя индексами-
концом и началом.


``` c#
abstract class AbstractQueue<T>
    // команды

    // постусловие: в хвост очереди добавлен новый элемент
    public void put_tail(T value);

    // предусловие: очередь не пуста
    // постусловие: из головы очереди удалён элемент
    public void rm_head();

    // запросы

    // предусловие: очередь не пуста
    public T get_head(); // получить элемент из головы очереди;

    public int size(); // текущий размер очереди

    // запросы статусов (возможные значения статусов)
    public int get_rm_head_status(); // успешно; очередь пуста
    public int get_get_head_status(); // успешно; очередь пуста


abstract class Queue<T> : AbstractQueue<T>
    // конструктор

    // постусловие: создана пустая очередь
    public Queue<T> Queue();


abstract class Deque<T> : AbstractQueue<T>
    // конструктор

    // постусловие: создана пустая очередь
    public Deque<T> Deque();

    // команды

    // предусловие: нет
    // постусловие: в голову помещен элемент value
    public void put_head(T value);

    // предусловие: в очереди есть элементы
    // постусловие: из хвоста очереди удален элемент
    public void rm_tail();

    // запросы

    // предусловие: в очереди есть элементы
    // постусловие: нет
    public T get_tail();

    // запросы статусов

    public int get_rm_head_status(); // успешно; очередь пуста
    public int get_get_tail_status(); // успешно; очередь пуста
```
