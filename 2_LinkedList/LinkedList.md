# Связный список

Далее мы рассмотрим базовые структуры данных из первого курса по алгоритмам, и разберёмся, почему предложенные там шаблоны классов слабые, и каковы будут правильные АТД для соответствующих типов данных.

Связный список. АТД LinkedList

Исходно у нас имелись такие методы:

addInTail(Node item) -- добавление узла в хвост списка;
insertAfter(Node nodeAfter, Node nodeToInsert) -- вставка узла после заданного
с дополнительным условием добавления элемента первым;
Node find(T value) -- поиск узла по значению;
findAll(T value) -- поиск всех узлов по значению;
remove(T value) -- удаление первого узла со значением Т;
removeAll(T value) -- удаление всех узлов со значением Т;
clear() -- очистка всего списка;
count() -- количество элементов в списке.

Недостатков у данного интерфейса немало. Например, команды поиска и удаления работают только с первым попавшимся узлом; одним методам передаются значения, а другим узлы, которые не очень понятно, откуда брать; реализации этих методов, судя по всему, везде потребуют циклов сканирования списка (сложность O(N)). А если в списке миллиарды элементов?

Но у данного подхода есть и более серьёзный, общий недостаток. В общем случае, переходя на уровень АТД, мы и должны думать только соответствующими абстракциями. А таких абстракций на уровне АТД всего две: это сам связный список, и хранимые в нём значения. Опускаясь же на уровень текущей реализации в виде данного шаблона, мы предлагаем совсем другой, более слабый уровень абстракции -- узлы списка и связи между ними. Кроме того, желательно, как уже отмечалось, чтобы АТД предлагал по возможности минималистичный набор операций, для работы которых не требовалось бы выполнять какие-то предварительные действия (например, создание или поиск узлов).

Сильное решение, применимое практически ко всем структурам данных, хотя бы немного идеологически отличающимся от классических массивов -- это понятие курсора.

Есть курсор, указывающий на некоторый узел в списке (курсор всегда указывает на некоторый узел, если список непустой), и есть набор операций, которые применяются к такому узлу, называемому "текущий узел".

С точки зрения пользователя АТД речь идёт не об узлах, а о значениях в списке, среди которых имеется текущее значение.

В таком случае можно обойтись набором из восьми атомарных (не сводимых друг к другу) операций:

-- head -- установить курсор на первый узел в списке;
-- tail -- установить курсор на последний узел в списке;
-- right -- сдвинуть курсор на один узел вправо;
-- get -- получить значение текущего узла;
-- put_right(значение) -- вставить следом за текущим узлом
                      новый узел с заданным значением;
-- put_left(значение) -- вставить перед текущим узлом
                      новый узел с заданным значением;
-- remove -- удалить текущий узел
             (курсор смещается к правому соседу, если он есть,
              в противном случае курсор смещается к левому соседу,
              если он есть);
-- clear -- очистить список;
-- size -- посчитать количество узлов в списке.

Кроме того, из соображений эффективности и удобства пользователей желательно добавить такие операции (хотя они и сводимы к другим элементарным операциям):

-- add_tail(значение) -- добавить новый узел в хвост списка;
-- replace(значение) -- заменить значение текущего узла на заданное;
-- find(значение) -- установить курсор на следующий узел
                  с искомым значением (по отношению к текущему узлу);
-- remove_all(значение) -- удалить в списке все узлы с заданным значением;
-- is_head -- находится ли курсор в начале списка?
-- is_tail -- находится ли курсор в конце списка?
-- is_value -- установлен ли курсор на какой-либо узел в списке
              (по сути, непустой ли список).

Задание 2.

2.1. Опишите АТД LinkedList с предложенным набором операций.
Разделите операции на запросы и команды.
Добавьте где необходимо предусловия и постусловия.
Добавьте запросы статуса команд, для работы которых требуются предусловия (учитывайте в частности случаи, когда список пустой).

2.2. Почему операция tail не сводима к другим операциям (если исходить из эффективной реализации)?

2.3. Операция поиска всех узлов с заданным значением, выдающая список таких
узлов, уже не нужна. Почему?
